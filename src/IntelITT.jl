module IntelITT

using CEnum

# these parts 

struct ___itt_string_handle
  strA::Cstring
  strW::Ptr{Cvoid}
  extra1::Cint
  extra2::Ptr{Cvoid}
  next::Ptr{___itt_string_handle}
end

const __itt_string_handle = ___itt_string_handle

@cenum ___itt_track_group_type::UInt32 begin
    __itt_track_group_type_normal = 0
end


const __itt_track_group_type = ___itt_track_group_type

@cenum ___itt_track_type::UInt32 begin
    __itt_track_type_normal = 0
end


const __itt_track_type = ___itt_track_type

struct ___itt_track
  name::Ptr{__itt_string_handle}
  group::Ptr{Cvoid}
  ttype::__itt_track_type
  extra1::Cint
  extra2::Ptr{Cvoid}
  next::Ptr{___itt_track}
end
const __itt_track = ___itt_track

struct ___itt_track_group
  name::Ptr{__itt_string_handle}
  track::Ptr{___itt_track}
  tgtype::__itt_track_group_type
  extra1::Cint
  extra2::Ptr{Cvoid}
  next::Ptr{___itt_track_group}
end
const __itt_track_group = ___itt_track_group

# generated by `Clang.jl`
#   we are not using the generated `libintelitt_api.jl`, but a manually modified version instead (lateron)
include("libintelitt_common.jl")

using Libdl
const LIBITTNOTIFY_PATH = joinpath(@__DIR__,"libittnotify/libittnotify.so")
const libittnotify = Ref{Ptr{Cvoid}}(C_NULL)

# the following makes a database of "known functions" where functions "register" during compile time (fn_names) and their pointers (fn_ptrs) are obtained on initialization (__init__)
const fn_ptrs   = Ptr{Cvoid}[]
const fn_names  = Symbol[]
const fn_namedb = Dict{Symbol,Int64}()

# macro to create, register and export a "pointered" function (these functions' symbols are suffixed with `XXXX_ptr__3_0`)
macro mkfnptr(name,rtype,argtypes,argnames...)
  # println("$name")
  # symname = Symbol(string(name) * "_ptr__3_0")
  # fn_ptr = dlsym(libittnotify, symname)
  fn_id =
    if haskey(fn_namedb,name)
      fn_namedb[name]
    else
      push!(fn_ptrs,C_NULL)
      symname = Symbol(string(name) * "_ptr__3_0")
      push!(fn_names,symname)
      id = length(fn_ptrs)
      fn_namedb[name] = id
      id
    end
  # println("  fn       = $symname")
  # println("  fn_id    = $fn_id")
  # println("  ptr      = $fn_ptr")
  # println("  rtype    = $rtype")
  # println("  argtypes = $argtypes")
  # println("  argnames = $argnames")
  f_typed = quote
    export $(esc(name))
    function $(esc(name))($( (:( $arg::$T ) for (arg,T) in zip(argnames,argtypes.args))... ))
      ccall($__module__.fn_ptrs[$fn_id], $rtype, ($(argtypes.args...),), $(argnames...))
    end
  end
  f_untyped = quote
    export $(esc(name))
    function $(esc(name))( $(argnames...) )
      ccall($__module__.fn_ptrs[$fn_id], $rtype, ($(argtypes.args...),), $(argnames...))
    end
  end
  Nargs = length(argtypes.args)
  if Nargs > 0
    quote
      export $(esc(name))
      $f_typed
      $f_untyped
    end
  else
    quote
      export $(esc(name))
      $f_typed
    end
  end
end

# macro to create, register and export a normal function
macro mkfn(name,rtype,argtypes,argnames...)
  # println("$name")
  # println("  rtype    = $rtype")
  # println("  argtypes = $argtypes")
  # println("  argnames = $argnames")
  # println("  argtypes :: $(typeof(argtypes.args))")
  # println("  argnames :: $(typeof(argnames))")
  f_typed = quote
    function $(esc(name))($( (:( $arg::$T ) for (arg,T) in zip(esc.(argnames),argtypes.args))... ))
      ccall(($(QuoteNode(name)),LIBITTNOTIFY_PATH), $rtype, ($(argtypes.args...),), $(esc.(argnames)...))
    end
  end
  f_untyped = quote
    function $(esc(name))( $(esc.(argnames)...) )
      ccall(($(QuoteNode(name)),LIBITTNOTIFY_PATH), $rtype, ($(argtypes.args...),), $(esc.(argnames)...))
    end
  end
  Nargs = length(argtypes.args)
  if Nargs > 0
    quote
      export $(esc(name))
      $f_typed
      $f_untyped
    end
  else
    quote
      export $(esc(name))
      $f_typed
    end
  end
end

function __init__()
  libittnotify[] = dlopen(Symbol(LIBITTNOTIFY_PATH))
  if libittnotify[] == C_NULL
    # create a shared object with
    #   ar x libittnotify.a
    #   gcc -shared ittnotify_static.o ittptmark64.o -o libittnotify.so
    error("could not open $LIBITTNOTIFY_PATH")
  end
  for n in 1:length(fn_names)
    x = dlsym(libittnotify[], fn_names[n])
    if x == C_NULL
      println("WARNING: could not get symbol for $(fn_names[n])")
    end
    fn_ptrs[n] = unsafe_load(convert(Ptr{Ptr{Cvoid}},x))
    if fn_ptrs[n] == C_NULL
      println("WARNING: could not get function pointer for $(fn_names[n])")
    end
  end
end

# this is a list of the api functions with the in
include("libintelitt_functions.jl")

export __itt_null
const __itt_null = __itt_id(UInt64(0),UInt64(0),UInt64(0))

# __init__()

end # module
